<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Paseo Professional Testing Suite</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,600;0,9..40,700;1,9..40,400&family=DM+Serif+Display&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js"></script>
    <style>
        :root {
            --pink: #FF2867;
            --grey-50: #FAFAF9;
            --grey-200: #E7E5E4;
            --grey-400: #A8A29E;
            --grey-800: #292524;
            --grey-900: #1C1917;
            --grey-950: #0F0F0F;
            --bg: #FAFAF9;
            --surface: #FFFFFF;
            --text-p: #1C1917;
            --text-s: #57534E;
            --border: #E7E5E4;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0F0F0F;
                --surface: #1C1917;
                --text-p: #FAFAF9;
                --text-s: #A8A29E;
                --border: #292524;
            }
        }

        * { box-sizing: border-box; }
        body, html {
            margin: 0; padding: 0; height: 100vh;
            background: var(--bg); color: var(--text-p);
            font-family: 'DM Sans', sans-serif; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }

        h1, .display-text { font-family: 'DM Serif Display', serif; font-weight: 400; }

        .app-shell {
            width: 1400px; height: 900px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            display: grid; grid-template-columns: 360px 1fr 360px;
            padding: 40px; gap: 30px;
            box-shadow: 0 40px 80px rgba(0,0,0,0.15);
        }

        .column { display: flex; flex-direction: column; gap: 20px; overflow: hidden; }

        .widget {
            background: transparent;
            border-bottom: 1px solid var(--border);
            padding: 0 0 20px 0;
            position: relative;
        }
        .label {
            font-size: 11px; color: var(--text-s);
            text-transform: uppercase; letter-spacing: 0.1em; font-weight: 700;
        }
        .val {
            font-family: 'DM Serif Display', serif;
            font-size: 32px; margin-top: 8px;
            color: var(--text-p);
        }
        .sub-val { font-size: 13px; color: var(--text-s); margin-top: 4px; }

        #console {
            flex-grow: 1; background: var(--bg); border-radius: 8px;
            border: 1px solid var(--border);
            padding: 24px; font-family: 'JetBrains Mono', monospace; font-size: 11px;
            color: var(--text-s); overflow-y: auto; line-height: 1.7;
        }
        .log-accent { color: var(--pink); font-weight: 600; }

        .btn-primary {
            background: var(--pink); border: none; color: #fff; padding: 20px;
            cursor: pointer; font-size: 14px;
            border-radius: 50px; font-weight: 600;
            transition: all 0.2s ease;
        }
        .btn-primary:hover { transform: translateY(-2px); filter: brightness(1.1); box-shadow: 0 10px 20px rgba(255, 40, 103, 0.2); }
        .btn-primary:disabled { background: var(--grey-400); cursor: not-allowed; transform: none; box-shadow: none; }

        .btn-secondary {
            background: transparent; color: var(--text-s);
            border: 1px solid var(--border); padding: 15px;
            border-radius: 50px; cursor: pointer; font-size: 12px; font-weight: 500;
        }
        .btn-secondary:hover { border-color: var(--text-p); color: var(--text-p); }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #ff6666, #ee2222);
        }

        .turbo-mode {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        #auth {
            position:fixed; inset:0; background:var(--bg); z-index:1000;
            display:flex; flex-direction:column; justify-content:center; align-items:center;
        }
        .auth-card {
            text-align: center; max-width: 400px; width: 100%;
        }
        input[type="password"] {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 8px; color: var(--text-p);
            width: 100%; padding: 20px; text-align: center;
            outline: none; font-size: 16px; margin-bottom: 20px;
            font-family: 'DM Sans', sans-serif;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-active { background: var(--pink); }
        .status-inactive { background: var(--grey-400); }

        .control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .intensity-slider {
            width: 100%;
            margin: 15px 0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: var(--border);
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--pink);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--pink);
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>

<div id="auth">
    <div class="auth-card">
        <h1 style="font-size:48px; margin:0 0 10px 0;">Paseo Suite</h1>
        <p style="color:var(--text-s); letter-spacing:3px; text-transform:uppercase; font-size:11px; margin-bottom:40px; font-weight:700;">Professional Testing v1.3</p>
        <input type="password" id="inputKey" placeholder="Private Key (0x...)">
        <button onclick="unlock()" class="btn-primary" style="width:100%;">Authenticate</button>
    </div>
</div>

<div class="app-shell" id="mainTerminal" style="display: none;">
    <div class="column">
        <div class="widget">
            <div class="label">Network Pulse</div>
            <div id="blockSpeed" class="val" style="color:var(--pink)">0.00s</div>
            <div class="sub-val" id="blockHeight">Block #--</div>
        </div>

        <div class="widget">
            <div class="label">Fuel Reserve</div>
            <div id="pasBalance" class="val">0.0000 PAS</div>
            <div class="sub-val">Status: <span id="walletStatus" style="color:var(--pink)">Nominal</span></div>
        </div>

        <div class="widget">
            <div class="label">Testing Suite</div>
            <div class="sub-val" style="word-break: break-all; font-family: 'JetBrains Mono'; margin-top:10px;">0x7a637dc8cbfb49edc55fbe97fab0b0824c163605</div>
        </div>

        <div class="widget">
            <div class="label">Token Factory</div>
            <div class="sub-val" style="word-break: break-all; font-family: 'JetBrains Mono'; margin-top:10px;">0x39ca236cb8131f6748d3862bb574f24a10e1c38d</div>
        </div>

        <div style="margin-top:auto; display:flex; flex-direction:column; gap:12px">
            <div class="widget" style="border: none; padding: 0;">
                <div class="label">Test Intensity</div>
                <div id="intensityValue" class="val" style="font-size: 24px;">50%</div>
                <input type="range" class="intensity-slider" id="intensity" min="1" max="100" value="50">
            </div>

            <div class="control-group">
                <button id="startTestBtn" class="btn-primary" onclick="startStressTest()">Start Test</button>
                <button id="stopTestBtn" class="btn-secondary" onclick="stopStressTest()">Stop Test</button>
            </div>

            <!-- Turbo Controls -->
            <!-- Turbo Controls -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <button id="turboBtn" class="btn-danger" onclick="toggleTurboMode()" style="grid-column: span 2;">üöÄ TURBO STRESS</button>
                <button class="btn-warning" onclick="batchOperations()">Batch Ops</button>
                <button class="btn-secondary" onclick="refreshStats()">Refresh</button>
            </div>

            <!-- Quick Actions Grid -->
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
                <button class="btn-primary" onclick="createContracts()">Create Contracts</button>
                <button class="btn-warning" onclick="createTokens()">Create Tokens</button>
                <button class="btn-secondary" onclick="loadTest()">Load Test</button>
                <button class="btn-secondary" onclick="distributedTest()">Distributed</button>
            </div>

            <!-- Settings -->
            <div class="form-group" style="margin-bottom: 15px;">
                <label>Batch Size: <span id="batchSizeValue">10</span></label>
                <input type="range" id="batchSize" min="5" max="50" value="10" oninput="updateBatchSize(this.value)" style="width: 100%;">
            </div>

            <!-- System Controls -->
            <button class="btn-secondary" onclick="location.reload()" style="width: 100%;">Terminate Session</button>

            <!-- Batch Settings -->
            <div class="form-group" style="margin-bottom: 15px;">
                <label>Batch Size: <span id="batchSizeValue">10</span></label>
                <input type="range" id="batchSize" min="5" max="50" value="10" oninput="updateBatchSize(this.value)">
            </div>

            <!-- Standard Controls -->
            <div class="control-group">
                <button class="btn-primary" onclick="createContracts()">Create Contracts</button>
                <button class="btn-warning" onclick="createTokens()">Create Tokens</button>
            </div>

            <div class="control-group">
                <button class="btn-secondary" onclick="loadTest()">Load Test</button>
                <button class="btn-secondary" onclick="distributedTest()">Distributed Test</button>
            </div>

            <div class="control-group">
                <button class="btn-secondary" onclick="loadTest()">Load Test</button>
                <button class="btn-secondary" onclick="distributedTest()">Distributed Test</button>
            </div>

            <button class="btn-secondary" onclick="refreshStats()" style="margin-top: 10px;">Refresh Stats</button>
            <button class="btn-secondary" onclick="location.reload()">Terminate Session</button>
        </div>
    </div>

    <div class="column">
        <div class="label" style="margin-bottom: 5px;">System Console</div>
        <div style="background: #ff4444; color: white; padding: 8px; margin-bottom: 10px; border-radius: 4px; font-size: 11px;">
            ‚ö†Ô∏è WARNING: High transaction frequency may trigger network spam protection.
        </div>
        <div id="console"></div>
    </div>

    <div class="column">
        <div class="widget">
            <div class="label">Child Contracts</div>
            <div id="childContracts" class="val">0</div>
            <div class="sub-val">Active Testing Contracts</div>
        </div>

        <div class="widget">
            <div class="label">Total Transactions</div>
            <div id="totalTransactions" class="val">0</div>
            <div class="sub-val">Executed Operations</div>
        </div>

        <div class="widget">
            <div class="label">Gas Price</div>
            <div id="gasPrice" class="val">-- gwei</div>
            <div class="sub-val">Network Fee Rate</div>
        </div>

        <div class="widget">
            <div class="label">Test Status</div>
            <div class="val">
                <span class="status-indicator" id="testStatusIndicator"></span>
                <span id="testStatus">Ready</span>
            </div>
            <div class="sub-val" id="testDuration">Duration: 0:00</div>
        </div>

        <div class="widget">
            <div class="label">Load Operations</div>
            <div id="loadOperations" class="val">0</div>
            <div class="sub-val">Executed Load Tests</div>
        </div>

        <div class="widget">
            <div class="label">Distributed Ops</div>
            <div id="distributedOps" class="val">0</div>
            <div class="sub-val">Multi-Contract Tests</div>
        </div>

        <div class="widget" style="margin-top:auto; border: none; background: var(--grey-50); padding: 20px; border-radius: 8px;">
            <div class="label" style="color:var(--pink)">Token Economy</div>
            <div id="tokenCount" class="val" style="font-size: 40px;">0</div>
            <div class="sub-val">Created Test Tokens</div>
        </div>
    </div>
</div>

<script>
    // Configuration
    const CONFIG = {
        rpc: "https://testnet-passet-hub-eth-rpc.polkadot.io",
        testingSuite: "0x7a637dc8cbfb49edc55fbe97fab0b0824c163605",
        tokenFactory: "0x39ca236cb8131f6748d3862bb574f24a10e1c38d",
        chainId: 420420422
    };

    // Global state
    let SESSION_KEY = "", isRunning = false, testStartTime = null;
    let turboMode = false, batchSize = 10, turboInterval = null, consecutiveErrors = 0;
    let operationInProgress = false;
    let testingSuite, tokenFactory, provider, wallet;

    // ABIs
    const testingSuiteABI = [
        "function createChildren(uint256 count)",
        "function startTest(uint256 intensity)",
        "function executeLoadTest(uint256 txCount)",
        "function executeDistributedTest()",
        "function stopTest()",
        "function getStats() view returns (uint256 children, uint256 txs, uint256 currentBlock, uint256 blocksElapsed, bool active)",
        "function childContractCount() view returns (uint256)",
        "function totalTransactions() view returns (uint256)"
    ];

    const tokenFactoryABI = [
        "function createTestTokens(uint256 count)",
        "function distributeTokens(address token, address[] memory recipients)",
        "function getTokenCount() view returns (uint256)"
    ];

    // Logging function
    function addLog(msg, isAccent = false) {
        const con = document.getElementById('console');
        const d = document.createElement('div');
        const colorClass = isAccent ? 'class="log-accent"' : '';
        d.innerHTML = `<span style="color:var(--grey-400)">[${new Date().toLocaleTimeString()}]</span> <span ${colorClass}>${msg}</span>`;
        con.prepend(d);
        if(con.childNodes.length > 50) con.removeChild(con.lastChild);
    }

        // Update intensity and batch size display
        document.getElementById('intensity').oninput = function() {
            document.getElementById('intensityValue').textContent = this.value + '%';
        };

        document.getElementById('batchSize').oninput = function() {
            batchSize = parseInt(this.value);
            document.getElementById('batchSizeValue').textContent = this.value;
        };

    // Authentication
    async function unlock() {
        const key = document.getElementById('inputKey').value.trim();
        try {
            provider = new ethers.JsonRpcProvider(CONFIG.rpc);
            wallet = new ethers.Wallet(key);
            SESSION_KEY = key;

                // Initialize contracts with connected wallet
            // Initialize contracts with connected wallet
            // Initialize contracts with connected wallet
            const connectedWallet = wallet.connect(provider);
            testingSuite = new ethers.Contract(CONFIG.testingSuite, testingSuiteABI, connectedWallet);
            tokenFactory = new ethers.Contract(CONFIG.tokenFactory, tokenFactoryABI, connectedWallet);

            document.getElementById('auth').style.display = 'none';
            document.getElementById('mainTerminal').style.display = 'grid';

            // Test contract connectivity before starting
            await testContractConnection();

            startMonitor();
            addLog("Professional Testing Suite activated.", true);
            addLog("üîß Fixed transaction encoding issues.", true);
            addLog("‚ö†Ô∏è  Turbo mode: single operations every 10 seconds.", true);
            addLog("üö® Network protection active - avoid spam detection.", true);
            addLog("üõ°Ô∏è Anti-spam protection: Operations limited to prevent network bans.", true);
            addLog("Ready for stable stress testing operations.", true);
        } catch (e) {
            alert("Invalid Credentials.");
            addLog("Authentication failed: " + e.message);
        }
    }

    // Network monitoring
    function startMonitor() {
        let lastB = Date.now();

        provider.on("block", async (num) => {
            document.getElementById('blockSpeed').innerText = ((Date.now()-lastB)/1000).toFixed(2) + "s";
            document.getElementById('blockHeight').innerText = "Block #" + num;
            lastB = Date.now();

            try {
                const balance = await provider.getBalance(wallet.address);
                document.getElementById('pasBalance').innerText = parseFloat(ethers.formatEther(balance)).toFixed(4) + " PAS";
                document.getElementById('walletStatus').innerText = "Nominal";

                try {
                    // Temporarily disable gas price monitoring to avoid v6 compatibility issues
                    document.getElementById('gasPrice').innerText = "Monitoring disabled";
                } catch (gasError) {
                    document.getElementById('gasPrice').innerText = "-- gwei";
                }



                await refreshStats();

            } catch (error) {
                document.getElementById('walletStatus').innerText = "Error";
                addLog("Monitor error: " + error.message);
            }
        });
    }

        // Test contract connection
        async function testContractConnection() {
            try {
                addLog("Testing contract connectivity...", true);
                const stats = await testingSuite.getStats();
                const childCount = await testingSuite.childContractCount();
                const tokenCount = await tokenFactory.getTokenCount();
                addLog("Contracts responding: TestingSuite ‚úì, TokenFactory ‚úì", true);
                return true;
            } catch (error) {
                addLog("Contract connectivity test failed: " + error.message);
                throw error;
            }
        }

        // Contract operations
        async function createContracts() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.querySelector('button[onclick*="createContracts"]');
            if (btn) btn.disabled = true;

            try {
                addLog("Creating child contracts...", true);
                await testContractConnection();

                const tx = await testingSuite.createChildren(3, { // Reduced from 10 to 3
                    gasLimit: 3000000,
                    gasPrice: ethers.parseUnits('1000', 'gwei') // Lower priority
                });
                addLog("TX: " + tx.hash);
                await tx.wait();
                addLog("Child contracts deployed successfully", true);
                await refreshStats();
            } catch (error) {
                addLog("Contract creation failed: " + error.message);
                // Retry with 1 contract only
                try {
                    const tx = await testingSuite.createChildren(1, {
                        gasLimit: 2000000,
                        gasPrice: ethers.parseUnits('500', 'gwei')
                    });
                    addLog("TX retry: " + tx.hash);
                    await tx.wait();
                    addLog("1 Child contract deployed successfully", true);
                    await refreshStats();
                } catch (retryError) {
                    addLog("Retry also failed: " + retryError.message);
                }
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }

        async function createTokens() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.querySelector('button[onclick*="createTokens"]');
            if (btn) btn.disabled = true;

            try {
                addLog("Creating test tokens...", true);
                const tx = await tokenFactory.createTestTokens(1, { // Reduced from 5 to 1
                    gasLimit: 3000000,
                    gasPrice: ethers.parseUnits('1000', 'gwei')
                });
                addLog("TX: " + tx.hash);
                await tx.wait();
                addLog("Test token created successfully", true);
                await refreshStats();
            } catch (error) {
                addLog("Token creation failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }

        async function startStressTest() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.getElementById('startTestBtn');
            if (btn) btn.disabled = true;

            const intensity = document.getElementById('intensity').value;
            try {
                addLog(`Starting stress test at ${intensity}% intensity...`, true);
                const tx = await testingSuite.startTest(intensity, {
                    gasLimit: 2000000,
                    gasPrice: ethers.parseUnits('1000', 'gwei')
                });
                addLog("TX: " + tx.hash);
                await tx.wait();

                isRunning = true;
                testStartTime = Date.now();
                document.getElementById('testStatus').innerText = "Active";
                document.getElementById('testStatusIndicator').className = "status-indicator status-active";
                addLog("Stress test initiated", true);
            } catch (error) {
                addLog("Stress test failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }

        async function stopStressTest() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.getElementById('stopTestBtn');
            if (btn) btn.disabled = true;

            try {
                addLog("Stopping stress test...", true);
                const tx = await testingSuite.stopTest({
                    gasLimit: 1000000,
                    gasPrice: ethers.parseUnits('1000', 'gwei')
                });
                await tx.wait();

                isRunning = false;
                testStartTime = null;
                document.getElementById('testStatus').innerText = "Stopped";
                document.getElementById('testStatusIndicator').className = "status-indicator status-inactive";
                document.getElementById('testDuration').innerText = "Duration: 0:00";
                addLog("Stress test terminated", true);
            } catch (error) {
                addLog("Stop test failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }

        async function loadTest() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.querySelector('button[onclick*="loadTest"]');
            if (btn) btn.disabled = true;

            try {
                addLog("Executing load test (50 transactions)...", true);
                const tx = await testingSuite.executeLoadTest(50, { // Reduced from 100 to 50
                    gasLimit: 2500000,
                    gasPrice: ethers.parseUnits('1000', 'gwei')
                });
                addLog("TX: " + tx.hash);
                await tx.wait();

                document.getElementById('loadOperations').innerText = parseInt(document.getElementById('loadOperations').innerText) + 1;
                addLog("Load test completed successfully", true);
                await refreshStats();
            } catch (error) {
                addLog("Load test failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }
    }

        async function distributedTest() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.querySelector('button[onclick*="distributedTest"]');
            if (btn) btn.disabled = true;

            try {
                addLog("Executing distributed test...", true);
                const tx = await testingSuite.executeDistributedTest({
                    gasLimit: 2000000,
                    gasPrice: ethers.parseUnits('1000', 'gwei')
                });
                await tx.wait();

                document.getElementById('distributedOps').innerText = parseInt(document.getElementById('distributedOps').innerText) + 1;
                addLog("Distributed test completed successfully", true);
                await refreshStats();
            } catch (error) {
                addLog("Distributed test failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }
        }

        // Turbo Mode Functions
        async function toggleTurboMode() {
            const btn = document.getElementById('turboBtn');

            if (turboMode) {
                // Stop turbo mode
                turboMode = false;
                if (turboInterval) {
                    clearInterval(turboInterval);
                    turboInterval = null;
                }
                btn.innerText = 'üöÄ TURBO STRESS';
                btn.classList.remove('turbo-mode');
                addLog("TURBO MODE DEACTIVATED", true);
            } else {
                // Start turbo mode
                turboMode = true;
                btn.innerText = 'üõë STOP TURBO';
                btn.classList.add('turbo-mode');
                addLog("TURBO MODE ACTIVATED - Maximum stress testing!", true);

                // Start automatic batch operations with longer intervals
                turboInterval = setInterval(async () => {
                    if (!turboMode) return;

                    try {
                        // Execute ONE operation at a time with longer delays
                        await executeSingleTurboOperation();
                        consecutiveErrors = 0; // Reset error counter on success
                    } catch (error) {
                        consecutiveErrors++;
                        addLog("Turbo operation error: " + error.message);

                        // Auto-stop after 3 consecutive errors
                        if (consecutiveErrors >= 3) {
                            addLog("üö® Too many consecutive errors! Auto-stopping turbo mode.", true);
                            toggleTurboMode();
                        }
                    }
                }, 10000); // Every 10 seconds - More conservative (reduced frequency)
            }
        }

        async function executeSingleTurboOperation() {
            const operationType = Math.floor(Math.random() * 4);

            try {
                switch (operationType) {
                    case 0:
                        await createSingleContract();
                        break;
                    case 1:
                        await createSingleToken();
                        break;
                    case 2:
                        await singleLoadTest();
                        break;
                    case 3:
                        await singleDistributedTest();
                        break;
                }
            } catch (error) {
                console.log("Single turbo operation error:", error);
                throw error; // Re-throw to be caught by caller
            }
        }

        async function createSingleContract() {
            try {
                addLog(`üî• Turbo: Creating 1 contract`, true);
                const tx = await testingSuite.createChildren(1, {
                    gasLimit: 2000000
                });

                // Wait for confirmation
                await tx.wait();
                addLog(`‚úÖ Turbo contract created`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Turbo contract failed: ${error.message}`, true);
                throw error;
            }
        }

        async function createContractsBatch() {
            // Keep original batch function for manual use
            try {
                const count = Math.min(3, 5); // Very small batch for manual use
                const tx = await testingSuite.createChildren(count, {
                    gasLimit: 4000000
                });
                addLog(`üî• Manual: Created ${count} contracts`, true);
                await tx.wait();
                addLog(`‚úÖ Manual contracts confirmed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Manual contracts failed: ${error.message}`, true);
            }
        }

        async function createSingleToken() {
            try {
                addLog(`üí∞ Turbo: Creating 1 token type`, true);
                const tx = await tokenFactory.createTestTokens(1, {
                    gasLimit: 3000000
                });

                await tx.wait();
                addLog(`‚úÖ Turbo token created`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Turbo token failed: ${error.message}`, true);
                throw error;
            }
        }

        async function createTokensBatch() {
            try {
                const count = Math.min(2, 3); // Very small batch for manual use
                const tx = await tokenFactory.createTestTokens(count, {
                    gasLimit: 6000000
                });
                addLog(`üí∞ Manual: Created ${count} token types`, true);
                await tx.wait();
                addLog(`‚úÖ Manual tokens confirmed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Manual tokens failed: ${error.message}`, true);
            }
        }

        async function singleLoadTest() {
            try {
                addLog(`‚ö° Turbo: Executing 50 load transactions`, true);
                const tx = await testingSuite.executeLoadTest(50, {
                    gasLimit: 2000000
                });

                await tx.wait();
                document.getElementById('loadOperations').innerText = parseInt(document.getElementById('loadOperations').innerText) + 1;
                addLog(`‚úÖ Turbo load test completed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Turbo load test failed: ${error.message}`, true);
                throw error;
            }
        }

        async function loadTestBatch() {
            try {
                const txCount = Math.min(100, 200); // Smaller batch for manual use
                const tx = await testingSuite.executeLoadTest(txCount, {
                    gasLimit: 3000000
                });
                addLog(`‚ö° Manual: ${txCount} load transactions`, true);
                document.getElementById('loadOperations').innerText = parseInt(document.getElementById('loadOperations').innerText) + 1;
                await tx.wait();
                addLog(`‚úÖ Manual load test confirmed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Manual load test failed: ${error.message}`, true);
            }
        }

        async function singleDistributedTest() {
            try {
                addLog(`üåê Turbo: Executing distributed test`, true);
                const tx = await testingSuite.executeDistributedTest({
                    gasLimit: 2000000
                });

                await tx.wait();
                document.getElementById('distributedOps').innerText = parseInt(document.getElementById('distributedOps').innerText) + 1;
                addLog(`‚úÖ Turbo distributed test completed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Turbo distributed test failed: ${error.message}`, true);
                throw error;
            }
        }

        async function distributedTestBatch() {
            try {
                const tx = await testingSuite.executeDistributedTest({
                    gasLimit: 2000000
                });
                addLog(`üåê Manual: Distributed operations`, true);
                document.getElementById('distributedOps').innerText = parseInt(document.getElementById('distributedOps').innerText) + 1;
                await tx.wait();
                addLog(`‚úÖ Manual distributed confirmed`, true);
                refreshStats();
            } catch (error) {
                addLog(`‚ùå Manual distributed failed: ${error.message}`, true);
            }
        }

        // Manual Batch Operations (Ultra Conservative)
        async function batchOperations() {
            if (operationInProgress) {
                addLog("‚ö†Ô∏è Operation already in progress, please wait...", true);
                return;
            }

            operationInProgress = true;
            const btn = document.querySelector('button[onclick*="batchOperations"]');
            if (btn) btn.disabled = true;

            addLog("üöÄ INITIATING ULTRA CONSERVATIVE BATCH - Minimal intensity!", true);

            try {
                // Execute operations sequentially with LONG delays
                await createContractsBatch();
                addLog("Waiting 5 seconds...", true);
                await new Promise(resolve => setTimeout(resolve, 5000));

                await createTokensBatch();
                addLog("Waiting 5 seconds...", true);
                await new Promise(resolve => setTimeout(resolve, 5000));

                await loadTestBatch();
                addLog("Waiting 5 seconds...", true);
                await new Promise(resolve => setTimeout(resolve, 5000));

                await distributedTestBatch();

                addLog("‚úÖ ULTRA CONSERVATIVE BATCH COMPLETED!", true);
                await refreshStats();

            } catch (error) {
                addLog("Ultra conservative batch failed: " + error.message);
            } finally {
                operationInProgress = false;
                if (btn) btn.disabled = false;
            }
        }

        function updateBatchSize(value) {
            batchSize = parseInt(value);
            document.getElementById('batchSizeValue').textContent = value;
            addLog(`Batch size updated to ${value}`, true);
        }

    async function refreshStats() {
        try {
            const stats = await testingSuite.getStats();
            const childCount = await testingSuite.childContractCount();
            const totalTx = await testingSuite.totalTransactions();
            const tokenCount = await tokenFactory.getTokenCount();

            document.getElementById('childContracts').innerText = childCount.toString();
            document.getElementById('totalTransactions').innerText = totalTx.toString();
            document.getElementById('tokenCount').innerText = tokenCount.toString();

            if (isRunning && testStartTime) {
                const duration = Math.floor((Date.now() - testStartTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                document.getElementById('testDuration').innerText = `Duration: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            addLog("Statistics refreshed");
        } catch (error) {
            addLog("Stats refresh failed: " + error.message);
        }
    }

    // Auto-refresh stats
    setInterval(() => {
        if (wallet && testingSuite) {
            refreshStats();
        }
    }, 10000);

    addLog("Paseo Professional Testing Suite initialized");
    addLog("Enter your private key to begin stress testing operations.");
</script>
</body>
</html>
